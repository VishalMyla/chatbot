# Neo DAO Functions

This document provides an overview of the Data Access Object (DAO) functions available in the Neo application. These functions operate across various blocks such as Script, Schema, and Mongo blocks and play a key role in connecting the application's business logic with its data sources.

# Overview

DAO functions handle the logic for accessing and manipulating data. They provide a simple and consistent way to interact with data from sources such as API requests and MongoDB blocks.

# DAO Functions

The following DAO functions are provided in Neo:

## getApiRequest

ThegetApiRequestfunction retrieves the API request made to the application. It returns the complete input request object, including the HTTP method, the requested URL, headers, and the request body.

`getApiRequest`

### Use cases

Scenario 1: Consider that you need to customise the response based on specific headers in the incoming API request.Usage: UsegetApiRequest() to access the request headers and determine how to customise the response.

`getApiRequest`

Scenario 2: Consider you need to validate the data in the request body before processing it.Usage: UsegetApiRequest() to access the request body and validate the data against your business rules before performing any operations.

`getApiRequest`

Syntax:const request = dao.getApiRequest();

`const request = dao.getApiRequest();`

Example Output

```
{ 
  method: "GET",
  url: "/api/data", 
  headers: { 
    "Authorization": "Bearer token"
  }, 
  body: {} 
}
```

```
{ 
  method: "GET",
  url: "/api/data", 
  headers: { 
    "Authorization": "Bearer token"
  }, 
  body: {} 
}
```

## getIn

The functiongetInreturns the input properties of the current block. These are the data or parameters that were passed to the block when it was executed.

`getIn`

### Use cases

Scenario 1: Consider you need to transform or process data that is passed to a block.Usage:  UsegetIn()to access the input properties, perform necessary transformations or calculations, and then use the results.

`getIn()`

Scenario 2: Consider you need to implement conditional logic based on the input properties.Usage: UsegetIn()to retrieve the input properties and apply conditional logic to execute different paths or actions depending on the values of parameters1 and parameter2.

`getIn()`

Input syntax:const input = dao.getIn();

`const input = dao.getIn();`

Output syntax

```
Example Output: 
{ 
  param1: "value1", 
  param2: "value2" 
}
```

```
Example Output: 
{ 
  param1: "value1", 
  param2: "value2" 
}
```

## getOut

ThegetOut()function retrieves the output data generated by a specific block after it has executed. By passing the block’s name as a parameter, you can access its output directly. If you don’t specify a block name,getOut()returns the output from the previous or parent block in the dataflow.

`getOut()`

`getOut()`

### Use Cases

Scenario 1: You need to use the output of a block executed earlier in the flow.Usage: CallgetOut()with the block’s name to retrieve its output. If no name is provided, the function returns the output from the previous or parent block.

`getOut()`

Scenario 2:  Consider you want to chain multiple blocks together where each block depends on the result of the previous one.Usage: UsegetOut()to access the output of the preceding block and feed this data into the next block for further processing.

`getOut()`

Input syntax:const output = dao.getOut("blockName");The block name is optional.

`const output = dao.getOut("blockName");`

Output syntax

```
{ 
  status: 200, 
  body: 
  { 
    "key": "value" 
  } 
}
```

```
{ 
  status: 200, 
  body: 
  { 
    "key": "value" 
  } 
}
```

## getBody

The functiongetBody()retrieves the body of the output response from a specified block.  If the block name is not specified, it retrieves the body from the previous or parent block. If the output from that block is an array, the function returnsundefined.

`getBody()`

`undefined`

### Use cases

Scenario 1: You need to access specific data from the response body of a block.Usage: UsegetBody()to retrieve the response body from a specified block. If you don’t provide a block name, the function returns the response body from the previous block.

`getBody()`

Scenario 2: Consider you need to debug or troubleshoot issues by examining the response body of a block.Usage:  UsegetBody()to access and inspect the response body. This allows you to identify any discrepancies or issues in the output data.

`getBody()`

Input syntax:const responseBody = dao.getBody("blockName");The block name is optional.

```
const responseBody = dao.getBody("blockName");
```

Output syntax

```
{ 
  "key": "value" 
}
```

```
{ 
  "key": "value" 
}
```

## getMultiBody

The functiongetMultiBody()is used when a block returns an array of responses, each with its own body. This function retrieves all the individual bodies from these responses and returns them as an array. If the block name is not specified, it retrieves the body from the previous or parent block.

`getMultiBody()`

### Use cases

Scenario 1: Consider you want to combine or analyse data from multiple response bodies returned by a block.Usage: UsegetMultiBody()to get an array of response bodies, then aggregate or analyse the data across all the responses.

`getMultiBody()`

Scenario 2: You need to validate each response body in a collection of responses to ensure it meets specific criteria.Usage: UsegetMultiBody()to retrieve the array of response bodies, and then iterate through each one to apply validation checks.

`getMultiBody()`

Input syntax:const responseBodies = dao.getMultiBody("blockName");The block name is optional.

```
const responseBodies = dao.getMultiBody("blockName");
```

Output syntax

```
[
  { 
    "data": "data1" 
  }, 
  { "data": "data2" 
  }
]
```

```
[
  { 
    "data": "data1" 
  }, 
  { "data": "data2" 
  }
]
```

## getHeaders

ThegetHeaders()function is used to retrieve the headers from the output response of a specific block. Headers are key-value pairs that provide essential metadata about the response.

`getHeaders()`

When you callgetHeaderswith a block name, the function returns an object containing all the headers associated with the output response of the specified block. If you don't specify a block name, it returns the headers of the previous or parent block by default.

`getHeaders`

### Use cases

Scenario 1: Consider you need to determine the content type of a response to handle it appropriately, such as parsing JSON or XML data.Usage: Usedao.getHeaders("blockName")to retrieve theContent-Typeheader from the response. This allows you to process the response data according to its type.

`dao.getHeaders("blockName")`

`Content-Type`

Scenario 2: Consider you need to verify that the response from a block includes a valid authorisation token before proceeding with sensitive operations.Usage: Usedao.getHeaders("blockName")to retrieve theAuthorisation headerand validate the token. This ensures that the response is secure and authorised.

`dao.getHeaders("blockName")`

`Authorisation header`

Input syntax:const headers = dao.getHeaders("blockName");The block name is optional.

```
const headers = dao.getHeaders("blockName");
```

Example output:

```
{ 
   "Content-Type": "application/json", 
   "Authorization": "Bearer token" 
 }
```

```
{ 
   "Content-Type": "application/json", 
   "Authorization": "Bearer token" 
 }
```

## getStatus

ThegetStatusfunction retrieves the HTTP status code from the response generated by a specific block in your application. This status code reflects the result of the block's operation, such as success, error, or another outcome. If the block's output is an array, the function returnsundefined.

`getStatus`

`undefined`

When you callgetStatuswith a block name, the function returns the status code for that specific block. If you do not specify the block name, the function returns the status code from the previous or parent block's output.

`getStatus`

### Use cases

Scenario 1: Consider you want to implement custom error-handling logic based on the status code returned by a specific block.Usage: UsegetStatus()to retrieve the status code from the block's output. This helps you determine the appropriate response or action based on the specific status code

`getStatus()`

Scenario 2: Consider you are executing multiple blocks in sequence, and the execution of a subsequent block depends on the success or failure (status code) of the previous block.Usage: UsegetStatus()to check the status code of the previous block. For example, if the status code is 200, whereas a different status code might trigger an alternative flow.

`getStatus()`

Input syntax:const statusCode = dao.getStatus("blockName");The block name is optional.

```
const statusCode = dao.getStatus("blockName");
```

Example Output: 200

## getMultiStatus

ThegetMultiStatusfunction retrieves multiple status codes when a block's output consists of an array of responses. Each response in the array has its status code, such as200,404, or500. ThegetMultiStatusfunction collects these status codes from each response and returns them as an array.

`getMultiStatus`

`200`

`404`

`500`

`getMultiStatus`

When you callgetMultiStatuswith a block name, the function returns the status code for that specific block. If you do not specify the block name, the function returns the status code from the previous or parent block's output.

`getMultiStatus`

### Use cases

Scenario 1: Consider you are processing a batch of requests where each request returns a response with its own status code. You need to handle or log the status codes for all responses.Usage: UsegetMultiStatus()to retrieve the status codes for all responses in the batch.

`getMultiStatus()`

Scenario 2: Consider you receive responses from multiple sources or services, and you need to make decisions based on the status codes from each response. For example, if any response indicates an error, you might want to trigger a specific action.Usage: UsegetMultiStatus()to access all status codes from the array of responses. This allows you to implement conditional logic based on the status codes, such as taking corrective actions if any response contains an error status.

`getMultiStatus()`

Input syntax:const statusCodes = dao.getMultiStatus("blockName");

```
const statusCodes = dao.getMultiStatus("blockName");
```

Example output: [200, 404]

## getQueryParams

ThegetQueryParamsfunction retrieves the query parameters from the output response of a specified block. Query parameters are key-value pairs included in the URL of a request. If the block's output is an array, the function returnsundefined.

`getQueryParams`

`undefined`

When you specify a block name,getQueryParamsreturns the query parameters from that particular block. If you don't provide a block name, the function defaults to returning the query parameters from the output of the previous or parent block.

`getQueryParams`

### Use cases

Scenario 1: Consider that you need to analyse the query parameters used in a specific block to verify the correctness of the request.Usage: UsegetQueryParams()to retrieve the query parameters from the specified block's output and verify the same.

`getQueryParams()`

Scenario 2: Consider that you need to generate reports based on different search criteria or pagination settings specified in query parameters.Usage: UsegetQueryParams()to extract query parameters such as search terms or page numbers from the block's output.

Input syntax:const queryParams = dao.getQueryParams("blockName");The block name is optional.

```
const queryParams = dao.getQueryParams("blockName");
```

Example output

```
{ 
  "search": "query", 
   "page": "1" 
}
```

```
{ 
  "search": "query", 
   "page": "1" 
}
```

## getPathParams

ThegetPathParamsfunction retrieves the path parameters from a specified block's output. If the output is an array, the function returnsundefined.

`getPathParams`

`undefined`

When you specify a block name,getPathParamsfetches the path parameters from that block. If you don't specify a block name, it retrieves the path parameters from the previous or parent block.

`getPathParams`

### Use cases

Scenario 1: Consider you need to extract and validate a specific path parameter, such as an ID, from a block's output before continuing with the next steps in the logic.Usage:  UsegetPathParams()to retrieve theidfrom the block's output, allowing you to validate or use it in subsequent operations.

`getPathParams()`

`id`

Scenario 2:  Consider you are working with multiple API endpoints, and each requires different path parameters. You want to dynamically retrieve these parameters based on the current block's execution.Usage: UsegetPathParams()to access the path parameters of the relevant block, enabling you to manage routing or processing logic based on the retrieved parameters.

`getPathParams()`

Input syntax:const pathParams = dao.getPathParams("blockName");The block name is optional.

```
const pathParams = dao.getPathParams("blockName");
```

Example Output

```
{ 
  "id": "123" 
}
```

```
{ 
  "id": "123" 
}
```

## getError

ThegetErrorfunction is designed to retrieve the error object from the output of a specified block. This error object contains details such as an error message and an error code, which help identify and diagnose issues that occur during the execution of that block. When the block's output is an array of responses, the function returnsundefined.

`getError`

`undefined`

When you specify a block name as an argument, the functiongetErrorfetches the error object from that specific block. If you do not specify a block name, the function returns the error object from the previous or parent block.

`getError`

### Use cases

Scenario 1: Consider you need to debug a specific block that fails during execution.Usage: UsegetError()to retrieve the error object from that block. This allows you to see the error message and code, helping diagnose and fix the issue.

`getError()`

Scenario 2: Consider you have a workflow where different actions depend on whether a block succeeds or fails.Usage: UsegetError()to check if the specified block encountered an error. If the function returns an error object, implement custom error handling or logging based on the error details.

`getError()`

Input syntax:const error = dao.getError("blockName");The block name is optional.

`const error = dao.getError("blockName");`

```
{ 
  "message": "An error occurred", "code": "500" 
}
```

```
{ 
  "message": "An error occurred", "code": "500" 
}
```

## getMultiError

ThegetMultiErrorfunction retrieves an array of error objects from the output response when a block's output consists of multiple responses. Each response in the array may have its error object. The function collects all these error objects and returns them as an array.

`getMultiError`

When you specify a block name,getMultiErrorfetches the array of errors from that specific block's output. If you don't provide a block name, the function defaults to retrieving the errors from the output of the previous or parent block.

`getMultiError`

### Use case

Scenario 1: Consider you are processing multiple API responses, each of which might contain its error object. You must collect and review all the errors to understand the issues across different responses.Usage: UsegetMultiError()to gather all error objects from each response in the array. This helps in aggregating error information for comprehensive troubleshooting or reporting.

`getMultiError()`

Scenario 2: Consider you are implementing a batch processing system where each response could have its error details. You need to handle errors for each item in the batch individually.Usage: UsegetMultiError()to retrieve and manage error details from all responses. This allows you to process errors for each response separately, such as logging them or triggering specific error handling workflows.

`getMultiError()`

Input syntax:const errors = dao.getMultiError("blockName");The block name is optional.

```
const errors = dao.getMultiError("blockName");
```

Example output

```
[
  { "message": "Error 1" }, 
  { "message": "Error 2" }
]
```

```
[
  { "message": "Error 1" }, 
  { "message": "Error 2" }
]
```

## hasError

ThehasError()function checks whether an error message exists in the output response of a specified block. It helps determine if the block encountered an error during execution. It returns a boolean value:trueif an error message is present andfalseotherwise.

`hasError()`

`true`

`false`

If you specify a block name, the function checks that specific block's output. If no block name is provided, it checks the output of the previous or parent block.

### Use case

Scenario: Consider a conditional logic based on whether a block encounters an error during execution. For example, you may need to trigger error handling or execute alternative logic if an error occurs.Usage: UsehasError()to check if the specified block generated an error. This enables you to create your logic according to the presence of errors, such as initiating an error handling routine if true.

`hasError()`

Input syntax:const hasError = dao.hasError("blockName");The block name is optional.

```
const hasError = dao.hasError("blockName");
```

Output: True or False

## getEffectiveHeaders

ThegetEffectiveHeaders()function retrieves headers relevant to API request processing by filtering out non-essential headers. It focuses on headers starting withx-capor those related to authorization. This function ensures you access crucial headers needed for authentication and interactions with the API gateway, including only the essential headers.

`getEffectiveHeaders()`

`x-cap`

### Use cases

Scenario 1: Consider you need to pass specific headers to an API gateway for proper request handling, such as custom headers for API management or authentication tokens.Usage: UsegetEffectiveHeaders()to retrieve only the relevant headers needed for the API request, such asx-capheaders or authorization tokens. This ensures you include all necessary information for authentication and API gateway processing, without extraneous headers that could interfere with the request.

`getEffectiveHeaders()`

`x-cap`

Scenario 2: Consider you are debugging an issue with API requests and need to verify which headers are sent for authentication and tracking purposes.Usage: UsegetEffectiveHeaders()to extract and review the headers applied to the API request. This helps you confirm that the requiredx-capheaders and authorization tokens are present and correctly formatted.

`getEffectiveHeaders()`

`x-cap`

Input syntax:const effectiveHeaders = dao.getEffectiveHeaders();

```
const effectiveHeaders = dao.getEffectiveHeaders();
```

Example output

```
{ 
  'x-cap-header': 'value', 
    'authorization': 'Bearer token'
}
```

```
{ 
  'x-cap-header': 'value', 
    'authorization': 'Bearer token'
}
```

## isSuccess

TheisSuccess()is a boolean function used to determine whether a previous operation or transaction was successful. It helps control the logic flow within a system, particularly in error handling and decision-making processes.

`isSuccess()`

isSuccess()checks if data retrieval or a transaction completes without errors. It returnstrueif successful, else it returnsfalse. Using this function, you can implement conditional logic based on the success of previous operations and effectively handle errors. This function does not require any input parameters.

`isSuccess()`

`true`

`false`

### Use case

Scenario: Consider an airport check-in system, the application first verifies whether it successfully retrieved a passenger’s data without errors. It then checks specific passenger details, such as a valid ticket and ID.

Usage 1:isSuccess() && (getOut().body.validPassenger)This condition confirms that the operation succeeded and the passenger data is valid. If both are true, the system proceeds with the check-in process.

```
isSuccess() && (getOut().body.validPassenger)
```

Usage 2:isSuccess() && (!getOut().body.validPassenger)This condition confirms that the operation succeeded, but the passenger data is invalid. If true, the system can trigger error handling or route the flow to manage the invalid passenger case.

```
isSuccess() && (!getOut().body.validPassenger)
```

## hasBlockBeenVisited

ThehasBlockBeenVisited()is a boolean function that checks whether a block has been visited during the dataflow execution.

`hasBlockBeenVisited()`

Syntax:hasBlockBeenVisited("blockName");

`hasBlockBeenVisited("blockName");`

Output: True or False

## getValueByKey

ThegetValueByKey()function retrieves a configuration value from theConfiguration Manager.

`getValueByKey()`

Syntax:getValueByKey('config name')Theconfig nameparameter is required and specifies the name of the configuration you want to retrieve.

`getValueByKey('config name')`

`config name`

Usage:const KeyLoyaltyId = getValueByKey('KeyLoyaltyId');

```
const KeyLoyaltyId = getValueByKey('KeyLoyaltyId');
```

## getParentValueByKey

In a connected organization setup, thegetParentValueByKey()function retrieves a configuration value stored in theConfiguration Managerat the parent organization level, from within a child organization.

`getParentValueByKey()`

Syntax:getParentValueByKey('config name')Theconfig nameparameter is required and specifies the name of the configuration to retrieve.

`getParentValueByKey('config name')`

`config name`

Usage:const parentConfig = getParentValueByKey('ParentKey');

```
const parentConfig = getParentValueByKey('ParentKey');
```

# DAO Methods Specific to Filters

## getDataFlowOut

ThegetDataFlowOut()function retrieves the output from a specified dataflow using thedagTypeparameter.dagTypeindicates the type of dataflow.

`getDataFlowOut()`

`dagType`

`dagType`

> 📘dagTypeThedagTypeis set to 'main' for the original or main data flow.ThedagTypeis set to '@PreMatching-P1/2/3' for pre-matching data flows.ThedagTypeis set to '@PostMatching-P1/2/3' for post-matching data flows.

## 📘dagType

dagType

- ThedagTypeis set to 'main' for the original or main data flow.

`dagType`

- ThedagTypeis set to '@PreMatching-P1/2/3' for pre-matching data flows.

`dagType`

- ThedagTypeis set to '@PostMatching-P1/2/3' for post-matching data flows.

`dagType`

## getLatestDataFlowOut

The functiongetLatestDataFlowOut()fetches the output from the latest execution of a dataflow without needing any parameters.

`getLatestDataFlowOut()`

## doesDataFlowHasError

The functiondoesDataFlowHasError()returns a boolean that indicates whether the specified dataflow encountered an error. Use thedagTypeparameter to specify the type of dataflow.

`doesDataFlowHasError()`

`dagType`

## doesLatestDataFlowHasError

The functiondoesLatestDataFlowHasError()returns a boolean that indicates whether the latest dataflow encounters an error. No parameters are required.

`doesLatestDataFlowHasError()`

## getDataFlowError

The functiongetDataFlowError()retrieves the error from a specific dataflow using thedagTypeparameter to identify the target DAG.

`getDataFlowError()`

`dagType`

## getLatestDataFlowError

The functiongetLatestDataFlowError()retrieves the error from the latest dataflow and does not require any parameters.

`getLatestDataFlowError()`

## getDataFlowBody

The functiongetDataFlowBody()retrieves the body of a specific dataflow using thedagTypeparameter to indicate which dataflow to access.

`getDataFlowBody()`

`dagType`

## getLatestDataFlowBody

The functiongetLatestDataFlowBody()retrieves the body from the latest dataflow execution without requiring any parameters.

`getLatestDataFlowBody()`

## getDataFlowMultiBody

The functiongetDataFlowMultiBody()is similar togetMultiBody, specifydagTypein the parameters.

`getDataFlowMultiBody()`

`dagType`

## getLatestDataFlowMultiBody

The functiongetLatestDataFlowMultiBody()is similar togetMultiBody.

`getLatestDataFlowMultiBody()`

## getLatestDataFlowStatus

ThegetLatestDataFlowStatus()function retrieves the status of the most recently executed dataflow.

`getLatestDataFlowStatus()`

Updated2 days ago